/**
 * Modal Component
 * Handles modal dialogs for displaying full analysis
 */
class Modal {
    constructor() {
        this.currentModal = null;
    }

    /**
     * Show full analysis in a modal
     * @param {string} competitorName - Name of the competitor
     * @param {string} fullAnalysis - Full analysis text
     */
    showFullAnalysis(competitorName, fullAnalysis) {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                this.closeModal();
            }
        };

        const modal = document.createElement('div');
        modal.className = 'modal-content';

        const body = document.createElement('div');
        body.className = 'modal-body';

        const content = document.createElement('div');
        content.className = 'modal-analysis-content';

        const formattedContent = this.formatAnalysisText(fullAnalysis);
        content.appendChild(formattedContent);

        body.appendChild(content);
        modal.appendChild(body);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        this.currentModal = overlay;

        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                this.closeModal();
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    }

    /**
     * Format analysis text with tabs and sections
     * @param {string} text - Analysis text to format
     * @returns {HTMLElement} Formatted content element
     */
    formatAnalysisText(text) {
        const container = document.createElement('div');

        const sections = this.parseAnalysisSections(text);

        if (sections.length > 1) {
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'analysis-tabs';

            const contentContainer = document.createElement('div');

            sections.forEach((section, index) => {
                const tab = document.createElement('button');
                tab.className = `analysis-tab ${index === 0 ? 'active' : ''}`;
                tab.innerHTML = `${section.icon} ${section.title}`;
                tab.onclick = () => this.switchAnalysisTab(index);
                tabsContainer.appendChild(tab);

                const tabContent = document.createElement('div');
                tabContent.className = `analysis-tab-content ${index === 0 ? 'active' : ''}`;
                tabContent.innerHTML = section.content;
                tabContent.setAttribute('data-tab-index', index);
                contentContainer.appendChild(tabContent);
            });

            container.appendChild(tabsContainer);
            container.appendChild(contentContainer);
        } else {
            const content = document.createElement('div');
            content.innerHTML = sections[0].content;
            container.appendChild(content);
        }

        return container;
    }

    /**
     * Switch between analysis tabs
     * @param {number} activeIndex - Index of the tab to activate
     */
    switchAnalysisTab(activeIndex) {
        const tabs = document.querySelectorAll('.analysis-tab');
        tabs.forEach((tab, index) => {
            if (index === activeIndex) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });

        const contents = document.querySelectorAll('.analysis-tab-content');
        contents.forEach((content, index) => {
            if (index === activeIndex) {
                content.classList.add('active');
            } else {
                content.classList.remove('active');
            }
        });
    }

    /**
     * Parse analysis text into sections
     * @param {string} text - Analysis text to parse
     * @returns {Array} Array of section objects
     */
    parseAnalysisSections(text) {
        const sections = [];

        // Split by numbered sections - improved regex to catch the specific analysis structure
        const mainSections = text.split(/(?=\d+[\.\)]\s*(?:–ö–æ–ø–∏—Ä–∞–π—Ç–∏–Ω–≥|–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥|–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è|–ü—Ä–æ–¥–∞–∂–∏|–ú–µ—Ç—Ä–∏–∫–∏|–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏|–ò—Ç–æ–≥–æ–≤—ã–π|–ö–æ–ø—ñ—Ä–∞–π—Ç–∏–Ω–≥|–ü—Å–∏—Ö–æ–ª–æ–≥—ñ—è|–ü—Ä–æ–¥–∞–∂—ñ|–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó|–í–∏—Å–Ω–æ–≤–∫–∏))/i);

        if (mainSections.length > 1) {
            const sectionIcons = {
                '–∫–æ–ø–∏—Ä–∞–π—Ç–∏–Ω–≥': { icon: '‚úçÔ∏è', name: '–ö–æ–ø—ñ—Ä–∞–π—Ç–∏–Ω–≥' },
                '–∫–æ–ø—ñ—Ä–∞–π—Ç–∏–Ω–≥': { icon: '‚úçÔ∏è', name: '–ö–æ–ø—ñ—Ä–∞–π—Ç–∏–Ω–≥' },
                '–º–∞—Ä–∫–µ—Ç–∏–Ω–≥': { icon: 'üìà', name: '–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥' },
                '–ø—Å–∏—Ö–æ–ª–æ–≥–∏—è': { icon: 'üß†', name: '–ü—Å–∏—Ö–æ–ª–æ–≥—ñ—è' },
                '–ø—Å–∏—Ö–æ–ª–æ–≥—ñ—è': { icon: 'üß†', name: '–ü—Å–∏—Ö–æ–ª–æ–≥—ñ—è' },
                '–ø—Ä–æ–¥–∞–∂–∏': { icon: 'üí∞', name: '–ü—Ä–æ–¥–∞–∂—ñ' },
                '–ø—Ä–æ–¥–∞–∂—ñ': { icon: 'üí∞', name: '–ü—Ä–æ–¥–∞–∂—ñ' },
                '–º–µ—Ç—Ä–∏–∫–∏': { icon: 'üìä', name: '–ú–µ—Ç—Ä–∏–∫–∏' },
                '—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏': { icon: 'üí°', name: '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó' },
                '—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó': { icon: 'üí°', name: '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó' },
                '–∏—Ç–æ–≥–æ–≤—ã–π': { icon: 'üéØ', name: '–í–∏—Å–Ω–æ–≤–∫–∏' },
                '–∏—Ç–æ–≥–æ–≤—ã–π –≤—ã–≤–æ–¥': { icon: 'üéØ', name: '–í–∏—Å–Ω–æ–≤–∫–∏' },
                '–≤–∏—Å–Ω–æ–≤–∫–∏': { icon: 'üéØ', name: '–í–∏—Å–Ω–æ–≤–∫–∏' },
                '–≤–∏—Å–Ω–æ–≤–æ–∫': { icon: 'üéØ', name: '–í–∏—Å–Ω–æ–≤–∫–∏' },
                '–∞–Ω–∞–ª—ñ–∑': { icon: 'üìã', name: '–ê–Ω–∞–ª—ñ–∑' },
                '–∞–Ω–∞–ª–∏–∑': { icon: 'üìã', name: '–ê–Ω–∞–ª—ñ–∑' },
                'swot': { icon: 'üîç', name: 'SWOT –ê–Ω–∞–ª—ñ–∑' },
                '–∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–∏': { icon: 'üè¢', name: '–ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–∏' },
                '—Ü—ñ–ª—å–æ–≤–∞': { icon: 'üéØ', name: '–¶—ñ–ª—å–æ–≤–∞ –∞—É–¥–∏—Ç–æ—Ä—ñ—è' },
                '—Ü—ñ–ª—å–æ–≤–æ—ó': { icon: 'üéØ', name: '–¶—ñ–ª—å–æ–≤–∞ –∞—É–¥–∏—Ç–æ—Ä—ñ—è' },
                '–∞—É–¥–∏—Ç–æ—Ä—ñ—è': { icon: 'üë•', name: '–¶—ñ–ª—å–æ–≤–∞ –∞—É–¥–∏—Ç–æ—Ä—ñ—è' },
                '–ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è': { icon: 'üìç', name: '–ü–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è' },
                '–±—Ä–µ–Ω–¥–∏–Ω–≥': { icon: 'üè∑Ô∏è', name: '–ë—Ä–µ–Ω–¥–∏–Ω–≥' }
            };

            mainSections.forEach(section => {
                const trimmed = section.trim();
                if (trimmed.length === 0) return;

                const titleMatch = trimmed.match(/^(\d+[\.\)]\s*)([^\n]+)/);
                if (titleMatch) {
                    const sectionTitle = titleMatch[2].trim();
                    const key = Object.keys(sectionIcons).find(key =>
                        sectionTitle.toLowerCase().includes(key)
                    );

                    const formattedContent = this.formatSectionContent(trimmed);

                    if (key) {
                        sections.push({
                            title: sectionIcons[key].name,
                            icon: sectionIcons[key].icon,
                            content: formattedContent
                        });
                    } else {
                        sections.push({
                            title: sectionTitle,
                            icon: 'üìù',
                            content: formattedContent
                        });
                    }
                } else {
                    sections.push({
                        title: '–ê–Ω–∞–ª—ñ–∑',
                        icon: 'üìù',
                        content: this.formatSectionContent(trimmed)
                    });
                }
            });
        }

        if (sections.length === 0) {
            sections.push({
                title: '–ê–Ω–∞–ª—ñ–∑',
                icon: 'üìù',
                content: this.formatSectionContent(text)
            });
        }

        return sections;
    }

    /**
     * Format section content with proper paragraphs and spacing
     * @param {string} content - Content to format
     * @returns {string} Formatted HTML content
     */
    formatSectionContent(content) {
        // Remove numbered prefix like "1) –ö–æ–ø–∏—Ä–∞–π—Ç–∏–Ω–≥"
        content = content.replace(/^\d+[\.\)]\s*[^\n]+\n?/, '');

        // Split into lines and clean them
        const lines = content.split('\n')
            .map(line => {
                // Remove all types of dashes (-‚Äì‚Äî‚Ä¢*) from the beginning of lines
                return line
                    .replace(/^\s*[-‚Äì‚Äî‚Ä¢*]\s*/, '')
                    .trim();
            })
            .filter(line => line.length > 0);

        // Try to detect if this is a structured analysis that should be formatted as a table
        const hasStructuredFormat = this.detectStructuredFormat(lines);
        
        if (hasStructuredFormat) {
            return this.formatAsStructuredTable(lines);
        } else {
            return this.formatAsRegularContent(lines);
        }
    }

    /**
     * Detect if content has structured format suitable for table display
     * @param {Array} lines - Array of content lines
     * @returns {boolean} True if structured format detected
     */
    detectStructuredFormat(lines) {
        // Look for patterns like "Category: Description" or bullet points with categories
        const structuredPatterns = [
            /^[^:]+:\s*.+$/, // Category: Description pattern
            /^[–ê-–Ø–∞-—è\w\s]+:\s*$/, // Category: (with colon at end)
            /^[–ê-–Ø–∞-—è\w\s]+\s*-\s*.+$/, // Category - Description pattern
        ];

        // Also look for common analysis keywords that suggest structured content
        const analysisKeywords = [
            '—Ç–∏–ø –æ—Ñ—Ñ–µ—Ä–∞', '—Å—Ç–∞–¥—ñ—è –≤–æ—Ä–æ–Ω–∫–∏', '—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å', '–æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å', '—Å–µ–∑–æ–Ω–Ω—ñ—Å—Ç—å',
            'value proposition', '—Ä–∏–∑–∏–∫-—Ä–µ–≤–µ—Ä—Å', '—Å–∏–ª–∞ —Å—Ç–∞', '—Ü—ñ–Ω–æ–≤–∞ –ø—Å–∏—Ö–æ–ª–æ–≥—ñ—è',
            'swot', 's:', 'w:', '–æ:', '—Ç:', 'mini-swot'
        ];

        let structuredCount = 0;
        let keywordCount = 0;
        
        lines.forEach(line => {
            const lowerLine = line.toLowerCase();
            
            // Check for structured patterns
            if (structuredPatterns.some(pattern => pattern.test(line))) {
                structuredCount++;
            }
            
            // Check for analysis keywords
            if (analysisKeywords.some(keyword => lowerLine.includes(keyword))) {
                keywordCount++;
            }
        });

        // Use structured format if:
        // 1. More than 30% of lines match structured patterns, OR
        // 2. Contains analysis keywords and has some structured patterns
        return (structuredCount > 0 && (structuredCount / lines.length) > 0.3) ||
               (keywordCount > 0 && structuredCount > 0);
    }

    /**
     * Format content as a structured table-like layout
     * @param {Array} lines - Array of content lines
     * @returns {string} Formatted HTML content
     */
    formatAsStructuredTable(lines) {
        let formatted = '<div class="analysis-structured-content">';
        
        lines.forEach((line, index) => {
            // Check for category: description pattern
            const categoryMatch = line.match(/^([^:]+):\s*(.*)$/);
            
            if (categoryMatch) {
                const category = categoryMatch[1].trim();
                const description = categoryMatch[2].trim();
                
                formatted += `
                    <div class="analysis-item">
                        <div class="analysis-label">${category}</div>
                        <div class="analysis-value">${description || '‚Äî'}</div>
                    </div>
                `;
            } else {
                // Check for category - description pattern
                const dashMatch = line.match(/^([^-]+)\s*-\s*(.+)$/);
                if (dashMatch) {
                    const category = dashMatch[1].trim();
                    const description = dashMatch[2].trim();
                    
                    formatted += `
                        <div class="analysis-item">
                            <div class="analysis-label">${category}</div>
                            <div class="analysis-value">${description}</div>
                        </div>
                    `;
                } else if (line.trim()) {
                    // Regular content line - treat as description only
                    formatted += `
                        <div class="analysis-item analysis-item-full">
                            <div class="analysis-value">${line}</div>
                        </div>
                    `;
                }
            }
        });
        
        formatted += '</div>';
        return formatted;
    }

    /**
     * Format content as regular paragraphs
     * @param {Array} lines - Array of content lines
     * @returns {string} Formatted HTML content
     */
    formatAsRegularContent(lines) {
        let formatted = '';
        let currentParagraph = '';

        lines.forEach((line, index) => {
            // Check if this line ends with a colon (likely a category header)
            const isCategoryHeader = line.match(/^([^:]+):\s*(.*)$/);
            
            if (isCategoryHeader) {
                // Flush previous paragraph
                if (currentParagraph) {
                    formatted += `<p class="analysis-paragraph">${currentParagraph}</p>`;
                    currentParagraph = '';
                }
                
                // Add category header as a separate paragraph
                const headerText = isCategoryHeader[1].trim();
                const contentAfterColon = isCategoryHeader[2].trim();
                const fullText = contentAfterColon ? `${headerText}: ${contentAfterColon}` : `${headerText}:`;
                formatted += `<p class="analysis-category">${fullText}</p>`;
            } else {
                // Regular content line
                if (currentParagraph) {
                    currentParagraph += ' ' + line;
                } else {
                    currentParagraph = line;
                }
            }
        });

        // Flush remaining paragraph
        if (currentParagraph) {
            formatted += `<p class="analysis-paragraph">${currentParagraph}</p>`;
        }

        return formatted || '<p class="analysis-paragraph">–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö</p>';
    }



    /**
     * Close the current modal
     */
    closeModal() {
        if (this.currentModal) {
            document.body.removeChild(this.currentModal);
            this.currentModal = null;
        }
    }

    /**
     * Check if modal is currently open
     * @returns {boolean} True if modal is open
     */
    isOpen() {
        return this.currentModal !== null;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Modal;
} else {
    window.Modal = Modal;
}